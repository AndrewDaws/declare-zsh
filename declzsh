#!/usr/bin/env zsh
# -*- mode: shell-script -*-
# vim:ft=zsh:sw=4:sts=4:et

# Started from Zle or from command line
#
# Copyright (c) 2017 Sebastian Gniazdowski

emulate -LR zsh -o extendedglob -o typesetsilent -o warncreateglobal

# Run as script?
if [[ "$0" != declzsh || -n "$ZSH_SCRIPT" ]]; then
    # Handle $0 according to the Zsh Plugin Standard:
    # http://zdharma.org/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html
    0="${${ZERO:-${0:#$ZSH_ARGZERO}}:-${(%):-%N}}"
    0="${${(M)0##/*}:-$PWD/$0}"
    fpath+=( "$0:h" )
fi

# Already autoloaded in *.plugin.zsh, here it's for Zshelldoc
autoload -- @declzsh-process-buffer

# Debug array, initially for the debug view in the ZUI app
local -a DECLZSH_DEBUG_MSGS

# Append message to the debug view
/declzsh-dbg() { DECLZSH_DEBUG_MSGS+=( "$*" ); }
# Append multiple messages to the debug view
/declzsh-dbg-array() { DECLZSH_DEBUG_MSGS+=( "$@" ); }
# Print-out the debug messages
/declzsh-dbg-print-out() {
    DECLZSH_DEBUG_MSGS=( "${DECLZSH_DEBUG_MSGS[@]/<ZSHRCSIZE>/$(( ${#zshrc} - 5 ))}" )
    local -a lines
    lines=( "${(f@)zshrc}" )
    DECLZSH_DEBUG_MSGS=( "${DECLZSH_DEBUG_MSGS[@]/<ZSHRCLINES>/${#lines}}" )

    { local ver="$(<${ZPLGM[BIN_DIR]}/.git/refs/heads/master)" } 2>/dev/null
    [[ -z "$ver" ]] && ver="unknown (no .git/refs/heads/master)" || ver="${ver[1,7]}"
    DECLZSH_DEBUG_MSGS=( "${DECLZSH_DEBUG_MSGS[@]/<ZPLGVERSION>/$ver}" )

    { local ver="$(<$DECLZSH_REPO_DIR/.git/refs/heads/master)" } 2>/dev/null
    [[ -z "$ver" ]] && ver="unknown (no .git/refs/heads/master)" || ver="${ver[1,7]}"
    DECLZSH_DEBUG_MSGS=( "${DECLZSH_DEBUG_MSGS[@]/<DECLZSHVERSION>/$ver}" )
    print -rl -- "${DECLZSH_DEBUG_MSGS[@]}";
}

local -a ice_order nval_ices
ice_order=(
    wait lucid silent service svn proto from teleid as id-as depth cloneopts
    ver has if load unload blockf pick bpick src notify mv cp atinit atclone
    atload atpull make run-atpull nocd cloneonly trackbinds bindmap multisrc
    compile nocompile nocompletions reset-prompt
    # Include all additional ices â€“ after
    # stripping them from the possible: ''
    ${(@s.|.)${ZPLG_EXTS[ice-mods]//\'\'/}}
)

nval_ices=(
        blockf silent lucid trackbinds cloneonly nocd run-atpull
        nocompletions svn
        # Include only those additional ices,
        # don't have the '' in their name, i.e.
        # aren't designed to hold value
        ${(@)${(@s.|.)ZPLG_EXTS[ice-mods]}:#*\'\'*}
)

# Initial debug message
/declzsh-dbg "ZSH version: $ZSH_VERSION ($ZSH_PATCHLEVEL), machine: $CPUTYPE $VENDOR $OSTYPE, LANG: $LANG"
if [[ ${+ZPLGM} = 1 ]]; then
    /declzsh-dbg "Zplugin version: <ZPLGVERSION>, declare-zshrc version: <DECLZSHVERSION>"
    /declzsh-dbg "Zplugin BIN_DIR: ${ZPLGM[BIN_DIR]/$HOME/~}, HOME_DIR: ${ZPLGM[HOME_DIR]/$HOME/~}, PLUGINS_DIR: ${ZPLGM[PLUGINS_DIR]/$HOME/~}, COMPLETIONS_DIR: ${ZPLGM[COMPLETIONS_DIR]/$HOME/~}"
else
    /declzsh-dbg "${ZUI[RED]}Zplugin not loaded${ZUI[FMT_END]}"
fi

/declzsh-dbg ""
/declzsh-dbg-array "Active plugins:" "${ZPLG_REGISTERED_PLUGINS[@]/(#s)/ }"
/declzsh-dbg ""

#
# CONSTANTS
#

local -A TOKEN_TYPES

TOKEN_TYPES=(

  # Precommand

  'builtin'     1
  'command'     1
  'exec'        1
  'nocorrect'   1
  'noglob'      1
  'pkexec'      1

  # Control flow
  # Tokens that at "command position" are followed by a command

  $'\x7b'   2 # {
  $'\x28'   2 # (
  '()'      2
  'while'   2
  'until'   2
  'if'      2
  'then'    2
  'elif'    2
  'else'    2
  'do'      2
  'time'    2
  'coproc'  2
  '!'       2

  # Command separators

  '|'   3
  '||'  3
  '&&'  3

  '|&'  4
  '&!'  4
  '&|'  4
  '&'   4
  ';'   4
)

#
# PARAMETERS
#

# Document to process
local zshrc_path="${1:-${ZDOTDIR:-$HOME}/.zshrc}" zshrc

#
# Parsing state-machine parameters
#

# The bits returned by -zplg-process-buffer
local token prev_token spaces prev_spaces next_token next_spaces

# Command detection
integer at_command=1 in_zplugin=0

# Functions
local fun_name
integer next_fun=0 cur_fun=0 prev_fun=0

# Depths in functions, i.e. -1 not in function, 0 in one function, etc.
integer depth=0 prev_depth=0 fun_depth=-1 anon_depth=-1 descentff=0 descentfa=0

# Nested functions tracking
integer nested_fun=0 next_nested_fun=0 prev_nested_fun=0
local -a fun_stack_depths

# Feature detection, call tree, reversed call tree
local -A features call_tree rev_call_tree funs
local -a known_functions sourced_files

# Text and commands data
integer was_zplugin=0 pre_block_end=0 post_block_begin=0
local -A cmd3
local -a cmdlist
integer coidx=1

#
# Other, general parameters
#

# Common
local -a mbegin mend match
local MATCH; integer MBEGIN MEND
local tmp
local REPLY
local -a reply

# @declzsh-process-buffer output parameters, declare
# them to prevent globals from being created
local -a DECLZSH_PB_WORDS DECLZSH_PB_SPACES \
          DECLZSH_PB_WORDS_BEGINNINGS DECLZSH_PB_ALL

#
# Examine zshrc
#

[[ ! -e "$zshrc_path" ]] && { print "No such file \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -f "$zshrc_path" ]] && { print "\`$zshrc_path' isn't a plain, regular file${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -r "$zshrc_path" ]] && { print "No read permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -w "$zshrc_path" ]] && { print "No write permissions to \`$zshrc_path'${ZDOTDIR:+ (using \$ZDOTDIR)}"; return 1; }
[[ ! -s "$zshrc_path" ]] && { print "File \`$zshrc_path' is empty, aborting"; return 1; }

local -A theme

# FUNCTION: .declzsh-tokenize-zsh-rc {{{
# Runs @declzsh-process-buffer() on $zshrc (containing the loaded
# .zshrc file). The *-process-buffer() is a general function that
# exists in other projects, is an autoload function, and is kept
# in separate file "@declzsh-process-buffer".
.declzsh-tokenize-zsh-rc() {
    @declzsh-process-buffer "$zshrc" 1
}
# }}}
# FUNCTION: .declzsh_verify_tokenization {{{
# To large extent verifies if tokenization was correct.
# Also removes the test-tokens added to input zshrc (this
# is how the verification is implemented - it is being
# checked if in the output data structures there's the
# `test' token - it's the last one to be parsed, so its
# existence in the structures confirms correct parsing
# of the preceding text, i.e. the whole zshrc).
.declzsh_verify_tokenization() {
    local lasta="${DECLZSH_PB_WORDS[-1]}" lastb="${DECLZSH_PB_ALL[-2]}"

    if [[ "$lasta" != "test" || "$lastb" != "test" ]]; then
        return 1
    fi

    DECLZSH_PB_WORDS[-1]=()
    DECLZSH_PB_SPACES[-1]=()
    DECLZSH_PB_SPACES[-1]="${DECLZSH_PB_SPACES[-1]%$'\n'}"
    DECLZSH_PB_ALL[-2,-1]=()
    DECLZSH_PB_ALL[-1]="${DECLZSH_PB_ALL[-1]%$'\n'}"

    return 0
}
# }}}
# FUNCTION: .declzsh_tokenization_failed {{{
# Outputs a message that zshrc didn't parse, and
# includes information what can be a possible cause.
.declzsh_tokenization_failed() {
    print -r -- "Failed to parse zshrc. Possible causes:"
    print -r -- ""
    print -r -- "1. Zsh <= 5.4.2 doesn't parse closing parenthesis ')' for '\$('"
    print -r -- "   if it is at other line, not at the same line as '\$('. So:"
    print -r -- ""
    print -r -- "     \$(ls -1 | perl -alne 'echo foo')"
    print -r -- ""
    print -r -- "   will parse correctly, while:"
    print -r -- ""
    print -r -- "     \$(ls -1 | perl -alne 'echo foo'"
    print -r -- "     )"
    print -r -- ""
    print -r -- "   will not. A more sophisticated not-parsing example:"
    print -r -- ""
    print -r -- "     asmcmds+=(\${(o)\$(ls -1 | perl -alne 'echo foo'"
    print -r -- "     )})"
    print -r -- ""
    print -r -- "2. A regular syntax error may exist, try: zcompile .zshrc, or"
    print -r -- "   start a zsh session and see if there are error messages."
    print -r -- ""
}
# }}}
# FUNCTION: .declzsh-process-zsh-rc {{{
# Parses tokens of the loaded zshrc and detects:
# - functions
# - block preceding zplugin commands
# - block with those commands
# - block following them
#
# Uses parameters filled by @declzsh-process-buffer:
# - $DECLZSH_PB_WORDS - tokens
# - $DECLZSH_PB_SPACES - spaces in front of each token, +1 at the end
.declzsh-process-zsh-rc() {
    integer i j size="${#DECLZSH_PB_WORDS}"

    for (( i=1; i<=size; ++ i )); do
        token="${DECLZSH_PB_WORDS[i]}"
        spaces="${DECLZSH_PB_SPACES[i]}"
        next_token="${DECLZSH_PB_WORDS[i+1]}"
        next_spaces="${DECLZSH_PB_SPACES[i+1]}"

        cur_fun=0 prev_fun=0 descentff=0 descentfa=0
        nested_fun=0 prev_nested_fun=0

        (( next_fun )) && { next_fun=0 cur_fun=1 prev_fun=0 anon_depth=-1; }
        (( next_nested_fun )) && { next_nested_fun=0 nested_fun=1 prev_nested_fun=0; }

        # Explicit future-function
        if [[ "$token" = "function"(|$'\r') && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            next_fun=1 cur_fun=0 prev_fun=0 anon_depth=-1
        # Detect top-level prev-function differentiating from anonymous function
        elif [[ "$token" = "()"(|$'\r') && ( "$fun_depth" -lt 0 ) && ( $anon_depth -lt 0 ) ]]; then
            if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [1234] ]]; then
                next_fun=0 cur_fun=0 prev_fun=0 anon_depth=$depth
            else
                next_fun=0 cur_fun=0 prev_fun=1 anon_depth=-1
            fi
        # Must be a nested future-function
        elif [[ "$token" = "function"(|$'\r') ]]; then
            next_nested_fun=1 nested_fun=0 prev_nested_fun=0
        # Is it a nested prev-function?
        elif [[ "$token" = "()"(|$'\r') && "$nested_fun" -eq 0 && "$depth" -gt "$fun_stack_depths[-1]" ]]; then
            if [[ "$spaces" != *$'\n'* && -n "$prev_token" && "${TOKEN_TYPES[$prev_token]}" != [1234] ]]; then
                next_nested_fun=0 nested_fun=0 prev_nested_fun=1
            fi
        elif [[ "$token" = "{"(|$'\r') ]]; then
            (( ++ depth ))
        elif [[ "$token" = "}"(|$'\r') ]]; then
            (( -- depth ))
        fi

        # Check if any final function-flag is raised
        if (( cur_fun )); then
            fun_name="${token%$'\r'}"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        elif (( prev_fun )); then
            fun_name="${prev_token%$'\r'}"
            fun_depth="$depth"
            fun_stack_depths+=( "$depth" )
        fi

        # Track nested functions
        if (( nested_fun + prev_nested_fun )); then
            fun_stack_depths+=( "$depth" )
        fi

        # Ascent to function - skip '{'
        if (( fun_depth >= 0 && depth == (fun_depth + 1) )) && [[ "$token" = "{"(|$'\r') ]]; then
            :
        # In function
        elif (( fun_depth >= 0 && depth > fun_depth )); then
            if [[ "$token" != [[:blank:]]#\#* ]]; then
                # : # do something with a non-comment function token
                funs[$fun_name]+="${spaces}${token}"
            fi
            # Handle descent from nested function
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # In anonymous-function
        elif (( anon_depth >= 0 && depth > anon_depth )); then
            if (( ${#fun_stack_depths} > 0 && depth == fun_stack_depths[-1] && prev_depth == fun_stack_depths[-1] + 1 )); then
                fun_stack_depths[-1]=()
            fi
        # Descent from function - skip '}'
        elif (( fun_depth >= 0 && depth == fun_depth && prev_depth == fun_depth + 1 )); then
            descentff=1
        # Descent from anon
        elif (( anon_depth >= 0 && depth == anon_depth && prev_depth == anon_depth + 1 )); then
            descentfa=1
        fi

        # Anon function in top-level
        if (( anon_depth >= 0 && fun_depth < 0 )); then
            [[ "$token" != [[:blank:]]#\#* ]] && preamble+="${spaces}${token}"
        fi

        ### Detect function call
        # Check for introduction of Zplugin call
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [1234] ]]; then
            at_command=1
            (( in_zplugin )) && {
                (( 2*i - 1 - post_block_begin > 7*4 )) && { /declzsh-dbg "WARNING: many non-Zplugin commands in Zplugin block"; }
                # A new command (i.e. $spaces has a new line, etc.) - move the post-block pointer
                post_block_begin=2*i-1
            }
            [[ "$token" != [[:blank:]]#\#* ]] && in_zplugin=0 || { (( in_zplugin )) && in_zplugin=1; }
        fi

        # Command token
        if (( at_command )); then
            at_command=0
            # Zplugin call not in function
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()"(|$'\r') && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ "$token" = (zplugin|zplg|zpl) || ( "$token" = ":" && "$next_token" = (zplugin|zplg|zpl) ) ]]; then
                    in_zplugin=1
                    (( was_zplugin == 0 )) && {
                        # Initially point the pre-block at the previous token
                        # (the result will be zero if zplugin command is first)
                        pre_block_end=2*(i-1)
                        for (( j=i-1; j >= 1; j -- )); do
                            # Include also some preceding comments
                            [[ "${DECLZSH_PB_WORDS[j]}" != [[:blank:]]#\#* || "${DECLZSH_PB_SPACES[j+1]}" = *$'\n'*$'\n'* ]] && { pre_block_end=2*j; break; }
                        done
                    }
                    was_zplugin=1

                    # Revive at_command mode if disabled zplugin command
                    [[ "$token" = ":" ]] && at_command=1
                fi
            fi

            # Prepare call-tree extraction
            # Search for this possible function ($token) in current script
            local tokenEx="${(q)name}/${(q)token}"
            local found="${known_functions[(r)$tokenEx]}" candidate="" last_candidate=""
            integer nth=1
            if [[ -z "$found" ]]; then
                # Search for other scripts having this possible function
                tokenEx="*/${(q)token}"
                while (( 1 )); do
                    candidate="${known_functions[(rn:nth:)$tokenEx]}"
                    if [[ -n "$candidate" ]]; then
                        last_candidate="$candidate"
                        found="${sourced_files[(r)*${candidate:h}*]}"
                        [[ -n "$found" ]] && break
                    else
                        break
                    fi
                    (( ++ nth ))
                done
                found="$last_candidate"
            fi
            if [[ -z "$fun_name" ]]; then
                local needle="${(q)name}/zsd_script_body"
            else
                local needle="${(q)name}/${(q)fun_name}"
            fi

            # Extract call-tree and reversed call-tree, and also features
            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && -n "$found" && "$fun_stack_depths[-1]" -le "0" ]]; then
                if [[ -z "$fun_name" ]]; then
                    [[ "${call_tree[${(q)name}/zsd_script_body]}" != *[[:blank:]]"${(q)found}"[[:blank:]]* ]] && {
                        call_tree[${(q)name}/zsd_script_body]+=" ${(q)found} "
                    }
                    [[ "${rev_call_tree[${(q)found}]}" != *[[:blank:]]"$needle"[[:blank:]]* ]] && {
                        rev_call_tree[${(q)found}]+=" ${(q)name}/zsd_script_body "
                    }
                else
                    [[ "${call_tree[${(q)name}/${(q)fun_name}]}" != *[[:blank:]]"${(q)found}"[[:blank:]]* ]] && {
                        call_tree[${(q)name}/${(q)fun_name}]+=" ${(q)found} "
                    }
                    [[ ${rev_call_tree[${(q)found}]} != *[[:blank:]]"$needle"[[:blank:]]* ]] && {
                        rev_call_tree[${(q)found}]+=" ${(q)name}/${(q)fun_name} "
                    }
                fi
            fi

            if [[ "$cur_fun" -eq 0 && "$next_token" != "()" && "$fun_stack_depths[-1]" -le "0" ]]; then
                # Features
                if [[ "$token" = ${(~j:|:)feature_list} ]]; then
                    [[ -z "$fun_name" ]] && local fkey="zsd_script_body" || local fkey="$fun_name"
                    [[ "${features[$fkey]}" != *[[:blank:]]"$token"[[:blank:]]* ]] && features[$fkey]+=" $token "
                    [[ "$token" = "source" ]] && sourced_files+=( "$next_token" )
                fi
            fi
        fi

        # Late disable of anonymous function
        if (( descentfa )); then
            anon_depth=-1
        # Late disable of normal function
        elif (( descentff )); then
            fun_name=""
            fun_depth=-1
            fun_stack_depths[-1]=()
        # No-function text gathering
        elif (( next_fun == 0 && cur_fun == 0 && prev_fun == 0 && anon_depth < 0 && fun_depth < 0 )); then
            if [[ "$next_token" != "()"(|$'\r') || "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$token]}" = [34] ]]; then
                [[ "$token" != [[:blank:]]#\#* ]] && : # do something with script-body token
            fi
        fi

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    # If zplugin command ended the zshrc, detect it here
    (( in_zplugin )) && post_block_begin=2*i-1

    if (( pre_block_end == 0 )); then
        # No zplugin commands -> pre-block ends at
        # the last token in the file
        (( post_block_begin == 0 )) && pre_block_end=2*(i-1)
    else
        j=0+(pre_block_end/2)

        # Soft command-separator?
        if [[ "${TOKEN_TYPES[${DECLZSH_PB_WORDS[j]}]}" = "3" ]]; then
            integer found=0
            for (( j=(pre_block_end/2)-1; j>=1; -- j )); do
                token="${DECLZSH_PB_WORDS[j]}"
                spaces="${DECLZSH_PB_SPACES[j]}"
                next_token="${DECLZSH_PB_WORDS[j+1]}"
                next_spaces="${DECLZSH_PB_SPACES[j+1]}"
                (( j >= 2 )) && prev_token="${DECLZSH_PB_WORDS[j-1]}" || prev_token=""

                if [[ "${TOKEN_TYPES[$token]}" = "4" ]]; then
                    found=1
                    pre_block_end=2*j
                    break
                # Soft command separator can have spaces after it
                elif [[ "$spaces" = *$'\n'* && "${TOKEN_TYPES[$prev_token]}" != "3" ]]; then
                    pre_block_end=2*(j-1)
                    found=1
                    break
                fi
            done

            # Didn't found, and therefore reached beginning of file
            (( found == 0 )) && pre_block_end=0
        fi
    fi

    if (( post_block_begin == 0 )); then
        post_block_begin=2*i-1
    else
        # Detect not related trailing comments
        for (( j=(post_block_begin+1)/2-1; j >= 1; -- j )); do
            [[ "${DECLZSH_PB_WORDS[j]}" = [[:blank:]]#\#* && "${DECLZSH_PB_WORDS[j]}" != [[:blank:]]#\#[[:blank:]]#zplugin* ]] && {
                post_block_begin=2*j-1
            } || break
        done

        # Detect if compinit follows
        integer count=$(( size-(post_block_begin+1)/2 ))
        local next_token_2
        (( count = (count > 15) ? 15 : count ))
        for (( j=(post_block_begin+1)/2; count > 0; ++ j, -- count )); do
            token="${DECLZSH_PB_WORDS[j]}"
            next_token="${DECLZSH_PB_WORDS[j+1]}"
            next_token_2="${DECLZSH_PB_WORDS[j+2]}"
            next_spaces="${DECLZSH_PB_SPACES[j+1]}"

            if [[ "$token" = "autoload" && ( "$next_token" = "compinit" || "$next_token_2" = "compinit" ) ]]; then
                [[ "$next_token" = "compinit" ]] && { post_block_begin=2*(j+2)-1; j+=1; count=count-1; }
                [[ "$next_token_2" = "compinit" ]] && { post_block_begin=2*(j+3)-1; j+=2; count=count-2; }
            elif [[ "$token" = "compinit" && ( "$next_spaces" = *$'\n'* || "${TOKEN_TYPES[$next_token]}" = 4 ) ]]; then
                # TODO: soft-connected following tokens can be also included
                post_block_begin=2*(j+1)-1
                break
            fi
        done
    fi
}
# }}}
# FUNCTION: .declzsh-process-zplugin-commands {{{
# Processes block with zplugin commands established earlier
# in .declzsh-process-zsh-rc() and generates $cmdlist array
# which holds serialized hashes of every zplugin invocation,
# mixed-in additional (external) commands, comments.
#
# Uses parameters filled by @declzsh-process-buffer:
# - $DECLZSH_PB_WORDS - tokens
# - $DECLZSH_PB_SPACES - spaces in front of each token, +1 at the end
.declzsh-process-zplugin-commands() {
    integer i
    cmd3=()

    # Reset parameters used in .declzsh-process-zsh-rc
    prev_depth=0 prev_token="" prev_spaces=""

    # From start to end of zplugin block
    # (pre_block_end/2)+1 - from the one space-token element after the pre-block
    # (post_block_begin+1)/2-1 - to one space-token element before the post-block
    # (post_block_begin+1)/2 - to the next, first element after last zplugin command
    for (( i=(pre_block_end/2)+1; i<=(post_block_begin+1)/2-1; ++ i )); do
        token="${DECLZSH_PB_WORDS[i]}"
        spaces="${DECLZSH_PB_SPACES[i]}"
        next_token="${DECLZSH_PB_WORDS[i+1]}"
        next_spaces="${DECLZSH_PB_SPACES[i+1]}"

        # New command?
        if [[ "$spaces" = *$'\n'* || -z "$prev_token" || "${TOKEN_TYPES[$prev_token]}" = [1234] ]]; then
            # Remember trailing spaces even though they might
            # get overwritten later, if the single command is
            # multi-line, i.e. if it uses \-line endings. The
            # last stored spaces are the command's spaces.
            if [[ "${TOKEN_TYPES[$prev_token]}" = [34] ]]; then
                # When command ends with explicit command separator,
                # then remember white spaces after that separator
                cmd3[aspaces]="$spaces"
            elif [[ "$spaces" != (|$'\r')$'\n' ]]; then
                # Remember spaces if they're not single newline, and
                # if what follows isn't a comment. So basically spaces
                # between commands are remembered. Spaces before comments
                # are not (but comment-remembering handles this)
                if [[ "$token" != [[:blank:]]#\#* ]]; then
                    cmd3[aspaces]="$spaces"
                fi
            fi

            if [[ "$spaces" != [[:blank:]]#"\\"(|$'\r')$'\n'[[:blank:]]# ]]; then
                in_zplugin=1

                if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
                    cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
                    /declzsh-dbg "Stored <ice>-cmd: ${cmdlist[coidx+1]}"
                elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
                    cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                    /declzsh-dbg "Stored <non-ice>-cmd: ${cmdlist[coidx+2]}"
                    coidx+=3
                else
                    # Don't increase coidx untill we get some command.
                    # This causes preceding comments to accumulate.
                    if [[ -n "${cmd3[c]}" ]]; then
                        # Custom command
                        cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
                        /declzsh-dbg "Stored <custom>-cmd: ${cmdlist[coidx+2]}"
                        coidx+=3
                    fi
                fi

                cmd3=()
            fi
        fi

        # Command token
        if [[ "$token" = [[:blank:]]#\#* ]]; then
            if (( in_zplugin == 1 )); then
                cmdlist[coidx]="${cmdlist[coidx]%%[[:space:]]##}"
                cmdlist[coidx]+="$spaces$token$next_spaces"
            else
                cmd3[comment]="$spaces$token"
            fi
        elif (( in_zplugin == 1 )); then
            [[ "$token" = (zplugin|zplg|zpl) ]] && cmd3[c]="zplugin" || cmd3[c]="$token"
            # Postpone current state to next token
            [[ "$token" = ":" ]] && { cmd3[disabled]=1; (( in_zplugin -- )); }
        elif (( in_zplugin == 2 )); then
            if [[ "${cmd3[c]}" = "zplugin" ]]; then
                [[ "$token" = (ice|load|light|snippet|cdclear|
                                cdreplay|env-whitelist|create)
                ]] && \
                        cmd3[sub]="$token" || \
                            { cmd3[sub]="unkn"; cmd3[unkn]="$token"; }
            else
                cmd3[arg_1]="$token"
                cmd3[spaces_1]="$spaces"
            fi
        else
            if [[ "${cmd3[sub]}" = "ice" ]]; then
                # Also dequote the ice modifier
                [[ "$token" = (#b)(${(~j:|:)ice_order})(?)(?)(*)(?) || \
                    "$token" = (#b)(${(~j:|:)ice_order})(*)
                ]] && {
                    local key="${match[1]}" string="${match[2]#[:=]}${match[3]}${match[4]}${match[5]}"
                    local second="${match[2]}" third="${match[3]}" last="${match[5]}"
                    cmd3[$key]="${string//(#b)(:|=|)([\"\']|\$\'|)(*)[\"\']/${match[3]}}"
                    # Remember also the quoting style, if the quoting
                    # is a recognized one
                    [[ ( -n "$second" && "$second" = "$last" ) || \
                        "$second" = (:|=)* # Via the star this handles both matchings
                    ]] && \
                        cmd3[${key}_style]="${second[1]}" || {
                            [[ "$second" = '$' && "$third" = "'" ]] && \
                                cmd3[${key}_style]="\$'"
                        }
                    ((1))
                } || {
                    cmd3[custom_$(( in_zplugin - 2 ))]="$token"
                    cmd3[spaces_$(( in_zplugin - 2 ))]="$spaces"
                }
            elif [[ "${cmd3[sub]}" = (load|light) ]]; then
                if (( in_zplugin == 4 )); then
                    cmd3[url]+="/$token"
                elif (( ${+cmd3[url]} == 0 )); then
                    cmd3[url]="$token"
                else
                    cmd3[custom_$(( in_zplugin - 2 ))]="$token"
                    cmd3[spaces_$(( in_zplugin - 2 ))]="$spaces"
                fi
            elif [[ "${cmd3[sub]}" = "snippet" ]]; then
                if [[ "$token" = "-f" ]]; then
                    cmd3[-f]="1"
                elif [[ "$token" = "--command" ]]; then
                    cmd3[--command]="1"
                elif [[ ${+cmd3[url]} != 1 && "${TOKEN_TYPES[$token]}" != [34] ]]; then
                    cmd3[url]="$token"
                else
                    cmd3[custom_$(( in_zplugin - 2 ))]="$token"
                    cmd3[spaces_$(( in_zplugin - 2 ))]="$spaces"
                fi
            elif [[ "${cmd3[sub]}" = "cdclear" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1" || {
                    cmd3[custom_$(( in_zplugin - 2 ))]="$token"
                    cmd3[spaces_$(( in_zplugin - 2 ))]="$spaces"
                }
            elif [[ "${cmd3[sub]}" = "cdreplay" ]]; then
                [[ "$token" = "-q" ]] && cmd3[-q]="1" || {
                    cmd3[custom_$(( in_zplugin - 2 ))]="$token"
                    cmd3[spaces_$(( in_zplugin - 2 ))]="$spaces"
                }
            elif [[ "${cmd3[sub]}" = "unkn" ]]; then
                # Argument following "zplugin <unknown> ..."
                cmd3[arg_$(( in_zplugin - 2 ))]="$token"
            else
                # Argument following "<unknown> <arg_1> ..."
                cmd3[arg_$(( in_zplugin - 1 ))]="$token"
                cmd3[spaces_$(( in_zplugin - 1 ))]="$spaces"
            fi
        fi

        # Advance deeper into "zplugin ..." if it wasn't comment
        #[[ "$token" != [[:blank:]]#\#* ]] && in_zplugin+=1
        in_zplugin+=1

        # History of state
        prev_depth="$depth"
        prev_token="$token"
        prev_spaces="$spaces"
    done

    if [[ -n "${cmd3[c]}" ]];then
        if [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" = "ice" ]]; then
            cmdlist[coidx+1]="${(j: :)${(qkv)cmd3[@]}}"
            /declzsh-dbg "Stored <ice>-cmd: ${cmdlist[coidx+1]}"
        elif [[ "${cmd3[c]}" = "zplugin" && "${cmd3[sub]}" != "ice" ]]; then
            cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
            /declzsh-dbg "Stored <non-ice>-cmd: ${cmdlist[coidx+2]}"
        elif [[ "${cmd3[c]}" != "zplugin" ]]; then
            cmdlist[coidx+2]="${(j: :)${(qkv)cmd3[@]}}"
            /declzsh-dbg "Stored <custom>-cmd: ${cmdlist[coidx+2]}"
        fi
        /declzsh-dbg "Zplugin block in zshrc has $(( (coidx + 2) / 3 )) commands (not counting \`zplugin ice ...')"
    else
        /declzsh-dbg "Zplugin block in zshrc has $(( (coidx-1) / 3 )) commands (not counting \`zplugin ice ...')"
    fi

    /declzsh-dbg ""
}
# }}}
# FUNCTION: .declzsh_util_swap {{{
# Swaps two variables given by name. Uses (P) substitution
# flag, can swap e.g. hash entries. For example:
#   local -A hash_arr=( a b c d )
#   .declzsh_util_swap 'hash_arr[a]' 'hash_arr[b]'
#
# $1 - name of first variable to swap
# $2 - name of second variable to swap
.declzsh_util_swap() {
    local __var_name1="$1" __var_name2="$2" __tmp
    integer set1="${(P)+__var_name1}" set2="${(P)+__var_name2}"

    if (( set1 && set2 )); then
        tmp="${(P)__var_name1}"
        : ${(P)__var_name1::=${(P)__var_name2}}
        : ${(P)__var_name2::=$tmp}
    elif (( set1 && !set2 )); then
        : ${(P)__var_name2::=${(P)__var_name1}}
        unset $__var_name1
    elif (( !set1 && set2 )); then
        : ${(P)__var_name1::=${(P)__var_name2}}
        unset $__var_name2
    fi
}
# }}}
# FUNCTION: .declzsh_action_move_up {{{
# Moves given instance ($2) up, i.e. swaps current and
# previous instance. Using "instance" here means: ZUI's
# module instance representing single zplugin command
# (possibly preceded with "zplugin ice ..." invocation)
# by the design of Crasis. Instance = invocation of a
# generator with "module_idx" "instance_idx" arguments.
#
# $1 - instance index
.declzsh_action_move_up() {
    local ice="$1" t

    local -a cmd1 cmd2

    (( (ice-1-1)*3+1 > ${#cmdlist} || (ice-1)*3 > ${#cmdlist} || (ice-1)*3+1 > ${#cmdlist} || ice*3 > ${#cmdlist} )) && return 1

    cmd1=( "${(@)cmdlist[(ice-1-1)*3+1,(ice-1)*3]}" )
    cmd2=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )

    cmdlist[(ice-1-1)*3+1,(ice-1)*3]=( "${cmd2[@]}" )
    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd1[@]}" )

    return 0
}
# }}}
# FUNCTION: .declzsh_action_move_down {{{
# Moves given instance ($2) down, i.e. swaps current and
# next instance. Using "instance" here means: ZUI's
# module instance representing single zplugin command
# (possibly preceded with "zplugin ice ..." invocation)
# by the design of Crasis. Instance = invocation of a
# generator with "module_idx" "instance_idx" arguments.
#
# $1 - instance index
.declzsh_action_move_down() {
    local ice="$1" t

    local -a cmd1 cmd2

    (( (ice-1)*3+1 > ${#cmdlist} || ice*3 > ${#cmdlist} || (ice-1+1)*3+1 > ${#cmdlist} || (ice+1)*3 > ${#cmdlist} )) && return 1

    cmd1=( "${(@)cmdlist[(ice-1)*3+1,ice*3]}" )
    cmd2=( "${(@)cmdlist[(ice-1+1)*3+1,(ice+1)*3]}" )

    cmdlist[(ice-1)*3+1,ice*3]=( "${cmd2[@]}" )
    cmdlist[(ice-1+1)*3+1,(ice+1)*3]=( "${cmd1[@]}" )

    return 0
}
# }}}
# FUNCTION: .declzsh_action_delete {{{
# Removes given entry from $cmdlist and orders full
# regeneration of document section holding the zplugin
# invocations (the main view). Basically, there will be
# one instance of module 2 less (the removed one), and
# remaining instances will get refreshed.
#
# $1 - instance index
.declzsh_action_delete() {
    local ice="$1"
    (( ice*3 > ${#cmdlist} || ice <= 0 )) && return 1
    cmdlist[(ice-1)*3+1,ice*3]=()
    return 0
}
# }}}
# FUNCTION: .declzsh_compose {{{
# Constructs text with zplugin commands, optionally
# including original Zshrc blocks (in order to create
# full .zshrc). Can skip comments (via $1).
#
# $1 - 0 or 1 - whether to include comments
# $2 - 0 or 1 - whether to generate complete zshrc
#
# $reply - lines of created code
.declzsh_compose() {
    local with_comments="$1" whole="$2" own_quoting="$3"
    local buf="" tmp comment key
    integer i size=$(( ${#cmdlist} / 3 ))
    local -a cmd keys
    local -A ice_cmd main_cmd

    [[ "$whole" = "1" ]] && {
        if (( pre_block_end > 0 )); then
            buf="${(j::)DECLZSH_PB_ALL[1,pre_block_end+1]}"
        else
            buf=""
        fi
    }

    for (( i=1; i<=size; ++ i )); do
        cmd=( "${(@)cmdlist[(i-1)*3+1,i*3]}" )
        comment="${cmd[1]}"
        ice_cmd=() main_cmd=()
        [[ -n "${cmd[2]}" ]] && ice_cmd=( "${(z@)cmd[2]}" )
        [[ -n "${cmd[3]}" ]] && main_cmd=( "${(z@)cmd[3]}" )

        ice_cmd=( "${(Qkv)ice_cmd[@]}" )
        main_cmd=( "${(Qkv)main_cmd[@]}" )

        # A horrible thing with $(<...) omitting trailing newlines
        [[ ${#buf} -gt 0 && ${buf[-1]} != $'\n' && $i -eq 1 ]] && buf+=$'\n'

        # Protection against previous command having trailing spaces before $'\n'
        local nl=$'\n'
        comment="${comment/[[:blank:]]##$nl/$nl}"

        # Comment
        [[ "$with_comments" = "1" && -n "$comment" ]] && {
            (( i == 1 )) && buf+="${comment##[[:space:]]##}" || buf+="${comment#$nl}"
        }

        # ICE
        # Something more than [c]=zplugin [sub]=ice [comment]=comment
        if (( ${#ice_cmd} > 2 && ${+ice_cmd[comment]} == 0 || ${#ice_cmd} > 3 && ${+ice_cmd[comment]} == 1 )); then
            (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
            buf+="zplugin ice"
            for tmp in "${ice_order[@]}"; do
                case "$tmp" in
                    (${(~j:|:)${ice_order:|nval_ices}})
                        if (( !own_quoting )); then
                            [[ -z "${ice_cmd[$tmp]}" && ${+ice_cmd[$tmp]} -eq 1 ]] && { buf+=" $tmp"; continue; }
                            [[ -z "${ice_cmd[$tmp]}" ]] && continue
                            local apos="'"
                            local quoted="${ice_cmd[${tmp}_style]}${ice_cmd[$tmp]}${${${(M)ice_cmd[${tmp}_style]:#\$\'}:+$apos}:-${ice_cmd[${tmp}_style]:#[:=]}}"
                            buf+=" $tmp$quoted"
                        else
                            [[ -z "${ice_cmd[$tmp]}" && ${+ice_cmd[$tmp]} -eq 1 ]] && { buf+=" $tmp"; continue; }
                            [[ -z "${ice_cmd[$tmp]}" ]] && continue
                            # Also quote the ice modifier
                            local opt1="\"${ice_cmd[$tmp]}\""
                            local opt2="'${ice_cmd[$tmp]}'"
                            [[ "${${opt1/\$ZPFX/}/\$/}" != "${opt1/\$ZPFX/}" \
                                # || "${opt1/\\\!/}" != "$opt1"
                            ]] && \
                                buf+=" $tmp$opt2" || buf+=" $tmp$opt1"
                        fi
                        ;;
                    (${(~j:|:)nval_ices})
                        (( ${+ice_cmd[$tmp]} == 0 )) && continue
                        buf+=" $tmp"
                        ;;
                esac
            done

            # Put tokens other than ice-mod at the
            # end, in order, with spaces
            keys=( "${(kon)ice_cmd[@]}" )
            for key in "${keys[@]}"; do
                [[ "$key" != custom_* ]] && continue
                buf+="${ice_cmd[spaces_${key#custom_}]}${ice_cmd[$key]}"
            done

            [[ "$with_comments" = "1" && -n "${ice_cmd[comment]}" ]] && buf+="${ice_cmd[comment]}"
            if [[ ${#ice_cmd} -gt 0 || "$i" -lt "$size" ]]; then
                (( ${+ice_cmd[aspaces]} )) && buf+="${ice_cmd[aspaces]}" || buf+=$'\n'
            fi
        fi

        # COMMAND
        if [[ "${#main_cmd}" -ge 1 ]]; then
            if [[ "${main_cmd[c]}" = (zplugin|zplg|zpl) ]]; then
                (( ice_cmd[disabled] || main_cmd[disabled] )) && buf+=": "
                if [[ "${main_cmd[sub]}" = (light|load|snippet|cdreplay|cdclear) ]]; then
                    buf+="zplugin ${main_cmd[sub]}"
                    [[ "${main_cmd[--command]}" = "1" ]] && buf+=" --command"
                    [[ "${main_cmd[-f]}" = "1" ]] && buf+=" -f"
                    [[ "${main_cmd[-q]}" = "1" ]] && buf+=" -q"
                    [[ -n "${main_cmd[url]}" ]] && buf+=" ${main_cmd[url]}"
                    [[ "$with_comments" = "1" && -n "${main_cmd[comment]}" ]] && buf+="${main_cmd[comment]}"

                    if [[ "$i" -lt "$size" ]]; then
                        (( ${+main_cmd[aspaces]} )) && buf+="${main_cmd[aspaces]}" || buf+=$'\n'
                    fi
                else
                    # Unknown subcommand
                    local text="${main_cmd[c]}"
                    [[ -n "${main_cmd[unkn]}" ]] && text+=" ${main_cmd[unkn]}"
                    keys=( "${(kon)main_cmd[@]}" )
                    for key in "${keys[@]}"; do
                        [[ "$key" != arg_* ]] && continue
                        text+=" ${main_cmd[$key]}"
                    done
                    buf+="$text"
                    if [[ "$i" -lt "$size" ]]; then
                        (( ${+main_cmd[aspaces]} )) && buf+="${main_cmd[aspaces]}" || buf+=$'\n'
                    fi
                fi
            else
                local text="${main_cmd[c]}"
                keys=( "${(kon)main_cmd[@]}" )
                for key in "${keys[@]}"; do
                    [[ "$key" != arg_* ]] && continue
                    text+="${main_cmd[spaces_${key#arg_}]}${main_cmd[$key]}"
                done
                buf+="$text"
                if [[ "$i" -lt "$size" ]]; then
                    (( ${+main_cmd[aspaces]} )) && buf+="${main_cmd[aspaces]}" || buf+=$'\n'
                fi
            fi
        fi
    done

    if (( pre_block_end+1 != post_block_begin )); then
        [[ "$whole" = "1" ]] && buf+="${(j::)DECLZSH_PB_ALL[post_block_begin,-1]}"
    fi

    reply=( "${(@f)buf}" )
}
# }}}
# FUNCTION: .declzsh_action_save {{{
# Called when [Save] pressed. Composes full .zshrc,
# performs the save, outputs status message.
.declzsh_action_save() {
    .declzsh_compose 1 1 0
    print -rl -- "${reply[@]}" >| "$zshrc_path"
    reply=()
    /declzsh-dbg "Saved to: \`$zshrc_path'"
}
# }}}
# FUNCTION: .declzsh_update_main_cmd {{{
# Updates main entry in given ($3) command packet. There
# is single command packet per zplugin invocation and it
# contains main command, optionally ICE command, and also
# optionally a preceding comment.
#
# $1 - key to update in the main command
# $2 - data to store under the key
# $3 - index of command pack to alter
.declzsh_update_main_cmd() {
    local key="$1" data="$2" idx="$3"
    local -a cmd
    local -A main_cmd

    cmd=( "${(@)cmdlist[(idx-1)*3+1,idx*3]}" )
    if [[ -n "${cmd[3]}" ]]; then
        main_cmd=( "${(z@)cmd[3]}" )
        main_cmd=( "${(Qkv)main_cmd[@]}" )
    fi
    if [[ "$data" = " delete " ]]; then
        unset "main_cmd[$key]"
    else
        main_cmd[$key]="$data"
    fi

    cmdlist[idx*3]="${(j: :)${(qkv)main_cmd[@]}}"
    return 0
}
# }}}
# FUNCTION: .declzsh_update_ice_cmd {{{
# Updates ICE entry in given ($3) command packet. There
# is single command packet per zplugin invocation and it
# contains main command, optionally ICE command, and also
# optionally a preceding comment.
#
# $1 - key to update in the ice command
# $2 - data to store under the key
# $3 - index of command pack to alter
.declzsh_update_ice_cmd() {
    local key="$1" data="$2" idx="$3"
    local -a cmd
    local -A ice_cmd

    cmd=( "${(@)cmdlist[(idx-1)*3+1,idx*3]}" )
    if [[ -n "${cmd[2]}" ]]; then
        ice_cmd=( "${(z@)cmd[2]}" )
        ice_cmd=( "${(Qkv)ice_cmd[@]}" )
    fi
    if [[ "$data" = " delete " ]]; then
        unset "ice_cmd[$key]"
    else
        ice_cmd[$key]="$data"
    fi

    local -a other
    other=( "${(@)ice_cmd[(I)(${(~j:|:)ice_order})]}" )
    if (( ${#other} == 0 )); then
        ice_cmd=( comment "${ice_cmd[comment]}" )
    else
        ice_cmd+=( c "zplugin" sub "ice" )
    fi

    cmdlist[idx*3-1]="${(j: :)${(qkv)ice_cmd[@]}}"
}
# }}}
# FUNCTION: .declzsh_action_add_snippet {{{
# Adds snippet to $cmdlist. So it creates a packet with
# "zplg snippet ..." main command.
.declzsh_action_add_snippet() {
    local url="${ZUI[my_tfield3_data]}"
    local -A main_cmd

    [[ -z "$url" || "$url" = \<*\> ]] && { -zui_std_stalog "" "" "" "WARNING: " "" "Aborted, please enter a proper snippet URL"; return; }
    [[ "$url" != /* && "$url" != (http|ftp|https|OMZ|PZT):* ]] && -zui_std_stalog "" "" "" "WARNING: " "" "Snippet isn't absolute path or URL"

    main_cmd[c]="zplugin"
    main_cmd[sub]="snippet"
    main_cmd[url]="$url"

    /declzsh-dbg "Prepending snippet (data: ${(kv)main_cmd})"

    cmdlist[1,0]=( "" "" "${(j: :)${(qkv)main_cmd[@]}}" )
}
# }}}
# FUNCTION: .declzsh_action_add_plugin {{{
# Adds plugin to $cmdlist. So it creates a packet with
# "zplg load/light ..." main command. Ice command can be
# added by editing actions.
.declzsh_action_add_plugin() {
    local url="${ZUI[my_tfield3_data]}"
    local -A main_cmd

    [[ -z "$url" ]] && { /declzsh-dbg "WARNING: Plugin addition aborted, please provide a proper plugin ID"; return 1; }
    [[ "$url" != [a-zA-Z0-9-]##/[a-zA-Z0-9-]## ]] && /declzsh-dbg "WARNING: Plugin ID isn't of the form \`user/plugin'"

    main_cmd[c]="zplugin"
    main_cmd[sub]="load"
    main_cmd[url]="$url"

    /declzsh-dbg "Prepending plugin (data: ${(kv)main_cmd})"

    cmdlist[1,0]=( "" "" "${(j: :)${(qkv)main_cmd[@]}}" )
}
# }}}
# FUNCTION: .declzsh_action_reload {{{
# Ran at startup. Performs full zshrc processing, recognizes
# other and zplugin-related zshrc parts, it regenerates the
# backend model-structure, the $cmdlist array of hashes.
.declzsh_action_reload() {
    local id="$1"
    float -F 2 sum=0.0
    local -a stats

    reply=()

    /declzsh-dbg "Loading \`$zshrc_path'..."
    zshrc="$(<$zshrc_path)"$'\ntest'
    /declzsh-dbg "Read <ZSHRCSIZE> bytes (<ZSHRCLINES> lines)"
    /declzsh-dbg ""

    print "Parsing zshrc..."
    cmdlist=()
    coidx=1
    stats=()

    [[ -n "$id" ]] && { /declzsh-dbg "[Reload] pressed"; /declzsh-dbg ""; }

    typeset -F 2 SECONDS=0
    .declzsh-tokenize-zsh-rc
    .declzsh_verify_tokenization || { .declzsh_tokenization_failed; return 1; }
    stats+=( "Tokenization time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    .declzsh-process-zsh-rc
    stats+=( "Main processing time: $SECONDS seconds" )
    sum+=SECONDS

    SECONDS=0
    .declzsh-process-zplugin-commands
    stats+=( "Zplugin-commands processing time: $SECONDS seconds" )
    sum+=SECONDS

    /declzsh-dbg-array "${stats[@]}" "Total time: $sum seconds" ""

    /declzsh-dbg "Read \`$zshrc_path' (time: $sum sec)"

    return 0
}
# }}}
.declzsh_action_reload || return 1

zshrc_path="$HOME/.zshrc_gen"
.declzsh_action_save
/declzsh-dbg-print-out

return 0
